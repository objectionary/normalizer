-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Command line normalizer of ùúë-calculus expressions.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/objectionary/eo-phi-normalizer#readme</a>
@package eo-phi-normalizer
@version 1.0.0


-- | The abstract syntax of language Syntax.
module Language.EO.Phi.Syntax.Abs
data Program
Program :: [Binding] -> Program
data MetaId
MetaIdLabel :: LabelMetaId -> MetaId
MetaIdTail :: TailMetaId -> MetaId
MetaIdBindings :: BindingsMetaId -> MetaId
MetaIdObject :: ObjectMetaId -> MetaId
MetaIdBytes :: BytesMetaId -> MetaId
data Object
Formation :: [Binding] -> Object
Application :: Object -> [Binding] -> Object
ObjectDispatch :: Object -> Attribute -> Object
GlobalObject :: Object
ThisObject :: Object
Termination :: Object
MetaSubstThis :: Object -> Object -> Object
MetaObject :: ObjectMetaId -> Object
MetaTailContext :: Object -> TailMetaId -> Object
MetaFunction :: MetaFunctionName -> Object -> Object
data Binding
AlphaBinding :: Attribute -> Object -> Binding
EmptyBinding :: Attribute -> Binding
DeltaBinding :: Bytes -> Binding
DeltaEmptyBinding :: Binding
LambdaBinding :: Function -> Binding
MetaBindings :: BindingsMetaId -> Binding
MetaDeltaBinding :: BytesMetaId -> Binding
data Attribute
Phi :: Attribute
Rho :: Attribute
Label :: LabelId -> Attribute
Alpha :: AlphaIndex -> Attribute
MetaAttr :: LabelMetaId -> Attribute
data RuleAttribute
ObjectAttr :: Attribute -> RuleAttribute
DeltaAttr :: RuleAttribute
LambdaAttr :: RuleAttribute
data PeeledObject
PeeledObject :: ObjectHead -> [ObjectAction] -> PeeledObject
data ObjectHead
HeadFormation :: [Binding] -> ObjectHead
HeadGlobal :: ObjectHead
HeadThis :: ObjectHead
HeadTermination :: ObjectHead
data ObjectAction
ActionApplication :: [Binding] -> ObjectAction
ActionDispatch :: Attribute -> ObjectAction
newtype Bytes
Bytes :: String -> Bytes
newtype Function
Function :: String -> Function
newtype LabelId
LabelId :: String -> LabelId
newtype AlphaIndex
AlphaIndex :: String -> AlphaIndex
newtype LabelMetaId
LabelMetaId :: String -> LabelMetaId
newtype TailMetaId
TailMetaId :: String -> TailMetaId
newtype BindingsMetaId
BindingsMetaId :: String -> BindingsMetaId
newtype ObjectMetaId
ObjectMetaId :: String -> ObjectMetaId
newtype BytesMetaId
BytesMetaId :: String -> BytesMetaId
newtype MetaFunctionName
MetaFunctionName :: String -> MetaFunctionName
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.Bytes
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.Bytes
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.Bytes
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.Bytes
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.Bytes
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.Bytes
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.Bytes
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.Function
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.Function
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.Function
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.Function
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.Function
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.Function
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.Function
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.LabelId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.LabelId
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.LabelId
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.LabelId
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.LabelId
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.LabelId
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.LabelId
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.AlphaIndex
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.AlphaIndex
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.AlphaIndex
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.AlphaIndex
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.AlphaIndex
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.AlphaIndex
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.AlphaIndex
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.LabelMetaId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.LabelMetaId
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.LabelMetaId
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.LabelMetaId
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.LabelMetaId
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.LabelMetaId
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.LabelMetaId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.Attribute
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.Attribute
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.Attribute
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.Attribute
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.Attribute
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.Attribute
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.RuleAttribute
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.RuleAttribute
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.RuleAttribute
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.RuleAttribute
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.RuleAttribute
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.RuleAttribute
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.TailMetaId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.TailMetaId
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.TailMetaId
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.TailMetaId
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.TailMetaId
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.TailMetaId
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.TailMetaId
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.BytesMetaId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.BytesMetaId
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.BytesMetaId
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.BytesMetaId
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.BytesMetaId
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.BytesMetaId
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.BytesMetaId
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.MetaId
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.MetaId
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.MetaId
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.MetaId
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.MetaId
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.MetaId
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.Binding
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.Binding
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.Binding
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.Binding
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.Binding
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.Binding
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.Object
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.Object
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.Object
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.Object
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.Object
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.Object
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.ObjectAction
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.ObjectAction
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.ObjectAction
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.ObjectAction
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.ObjectAction
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.ObjectAction
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.ObjectHead
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.ObjectHead
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.ObjectHead
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.ObjectHead
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.ObjectHead
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.ObjectHead
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.PeeledObject
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.PeeledObject
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.PeeledObject
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.PeeledObject
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.PeeledObject
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.PeeledObject
instance GHC.Generics.Generic Language.EO.Phi.Syntax.Abs.Program
instance Data.Data.Data Language.EO.Phi.Syntax.Abs.Program
instance GHC.Read.Read Language.EO.Phi.Syntax.Abs.Program
instance GHC.Show.Show Language.EO.Phi.Syntax.Abs.Program
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Abs.Program
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Abs.Program

module Language.EO.Phi.Syntax.Lex
alex_tab_size :: Int
alex_base :: AlexAddr
alex_table :: AlexAddr
alex_check :: AlexAddr
alex_deflt :: AlexAddr
alex_accept :: Array Int (AlexAcc user)
alex_actions :: Array Int (Posn -> String -> Token)
alex_action_3 :: Posn -> String -> Token
alex_action_4 :: Posn -> String -> Token
alex_action_5 :: Posn -> String -> Token
alex_action_6 :: Posn -> String -> Token
alex_action_7 :: Posn -> String -> Token
alex_action_8 :: Posn -> String -> Token
alex_action_9 :: Posn -> String -> Token
alex_action_10 :: Posn -> String -> Token
alex_action_11 :: Posn -> String -> Token
alex_action_12 :: Posn -> String -> Token
alex_action_13 :: Posn -> String -> Token
alex_action_14 :: Posn -> String -> Token
data AlexAddr
AlexA# :: Addr# -> AlexAddr
alexIndexInt16OffAddr :: AlexAddr -> Int# -> Int#
alexIndexInt32OffAddr :: AlexAddr -> Int# -> Int#
quickIndex :: Array Int (AlexAcc (Any :: Type)) -> Int -> AlexAcc (Any :: Type)
data AlexReturn a
AlexEOF :: AlexReturn a
AlexError :: !AlexInput -> AlexReturn a
AlexSkip :: !AlexInput -> !Int -> AlexReturn a
AlexToken :: !AlexInput -> !Int -> a -> AlexReturn a
alexScan :: (Posn, Char, [Byte], String) -> Int -> AlexReturn (Posn -> String -> Token)
alexScanUser :: t -> (Posn, Char, [Byte], String) -> Int -> AlexReturn (Posn -> String -> Token)
alex_scan_tkn :: t -> t -> Int# -> AlexInput -> Int# -> AlexLastAcc -> (AlexLastAcc, (Posn, Char, [Byte], String))
data AlexLastAcc
AlexNone :: AlexLastAcc
AlexLastAcc :: !Int -> !AlexInput -> !Int -> AlexLastAcc
AlexLastSkip :: !AlexInput -> !Int -> AlexLastAcc
data AlexAcc user
AlexAccNone :: AlexAcc user
AlexAcc :: Int -> AlexAcc user
AlexAccSkip :: AlexAcc user

-- | Create a token with position.
tok :: (String -> Tok) -> Posn -> String -> Token

-- | Token without position.
data Tok

-- | Reserved word or symbol.
TK :: {-# UNPACK #-} !TokSymbol -> Tok

-- | String literal.
TL :: !String -> Tok

-- | Integer literal.
TI :: !String -> Tok

-- | Identifier.
TV :: !String -> Tok

-- | Float literal.
TD :: !String -> Tok

-- | Character literal.
TC :: !String -> Tok
T_Bytes :: !String -> Tok
T_Function :: !String -> Tok
T_LabelId :: !String -> Tok
T_AlphaIndex :: !String -> Tok
T_LabelMetaId :: !String -> Tok
T_TailMetaId :: !String -> Tok
T_BindingsMetaId :: !String -> Tok
T_ObjectMetaId :: !String -> Tok
T_BytesMetaId :: !String -> Tok
T_MetaFunctionName :: !String -> Tok

-- | Smart constructor for <a>Tok</a> for the sake of backwards
--   compatibility.
pattern TS :: String -> Int -> Tok

-- | Keyword or symbol tokens have a unique ID.
data TokSymbol
TokSymbol :: String -> !Int -> TokSymbol

-- | Keyword or symbol text.
[tsText] :: TokSymbol -> String

-- | Unique ID.
[tsID] :: TokSymbol -> !Int

-- | Token with position.
data Token
PT :: Posn -> Tok -> Token
Err :: Posn -> Token

-- | Pretty print a position.
printPosn :: Posn -> String

-- | Pretty print the position of the first token in the list.
tokenPos :: [Token] -> String

-- | Get the position of a token.
tokenPosn :: Token -> Posn

-- | Get line and column of a token.
tokenLineCol :: Token -> (Int, Int)

-- | Get line and column of a position.
posLineCol :: Posn -> (Int, Int)

-- | Convert a token into "position token" form.
mkPosToken :: Token -> ((Int, Int), String)

-- | Convert a token to its text.
tokenText :: Token -> String

-- | Convert a token to a string.
prToken :: Token -> String

-- | Finite map from text to token organized as binary search tree.
data BTree

-- | Nil (leaf).
N :: BTree

-- | Binary node.
B :: String -> Tok -> BTree -> BTree -> BTree

-- | Convert potential keyword into token or use fallback conversion.
eitherResIdent :: (String -> Tok) -> String -> Tok

-- | The keywords and symbols of the language organized as binary search
--   tree.
resWords :: BTree

-- | Unquote string literal.
unescapeInitTail :: String -> String
data Posn
Pn :: !Int -> !Int -> !Int -> Posn
alexStartPos :: Posn
alexMove :: Posn -> Char -> Posn
type Byte = Word8
type AlexInput = (Posn, Char, [Byte], String)
tokens :: String -> [Token]
alexGetByte :: AlexInput -> Maybe (Byte, AlexInput)
alexInputPrevChar :: AlexInput -> Char

-- | Encode a Haskell String to a list of Word8 values, in UTF8 format.
utf8Encode :: Char -> [Word8]
instance GHC.Show.Show Language.EO.Phi.Syntax.Lex.TokSymbol
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Lex.Tok
instance GHC.Show.Show Language.EO.Phi.Syntax.Lex.Tok
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Lex.Tok
instance GHC.Show.Show Language.EO.Phi.Syntax.Lex.BTree
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Lex.Posn
instance GHC.Show.Show Language.EO.Phi.Syntax.Lex.Posn
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Lex.Posn
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Lex.Token
instance GHC.Show.Show Language.EO.Phi.Syntax.Lex.Token
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Lex.Token
instance GHC.Classes.Eq Language.EO.Phi.Syntax.Lex.TokSymbol
instance GHC.Classes.Ord Language.EO.Phi.Syntax.Lex.TokSymbol

module Language.EO.Phi.Syntax.Par
happyError :: [Token] -> Err a
myLexer :: String -> [Token]
pProgram :: [Token] -> Err Program
pMetaId :: [Token] -> Err MetaId
pObject :: [Token] -> Err Object
pBinding :: [Token] -> Err Binding
pListBinding :: [Token] -> Err [Binding]
pAttribute :: [Token] -> Err Attribute
pRuleAttribute :: [Token] -> Err RuleAttribute
pPeeledObject :: [Token] -> Err PeeledObject
pObjectHead :: [Token] -> Err ObjectHead
pObjectAction :: [Token] -> Err ObjectAction
pListObjectAction :: [Token] -> Err [ObjectAction]

module Language.EO.Phi.Rules.Common
parseWith :: ([Token] -> Either String a) -> String -> Either String a

-- | Parse a <a>Object</a> from a <a>String</a>. May throw an <a>error</a>
--   if input has a syntactical or lexical errors.
unsafeParseWith :: ([Token] -> Either String a) -> String -> a

-- | State of evaluation is not needed yet, but it might be in the future
type EvaluationState = ()
type NamedRule = (String, Rule)
type Atoms = HashMap String (String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState))
data Context
Context :: Bool -> [NamedRule] -> Atoms -> Atoms -> NonEmpty Object -> Attribute -> Bool -> Bool -> Bool -> Bool -> Bool -> Context
[builtinRules] :: Context -> Bool
[allRules] :: Context -> [NamedRule]
[enabledAtoms] :: Context -> Atoms
[knownAtoms] :: Context -> Atoms
[outerFormations] :: Context -> NonEmpty Object
[currentAttr] :: Context -> Attribute

-- | Temporary hack for applying Ksi and Phi rules when dataizing
[insideFormation] :: Context -> Bool
[insideAbstractFormation] :: Context -> Bool

-- | Temporary flag to only dataize Package attributes for the top-level
--   formation.
[dataizePackage] :: Context -> Bool
[minimizeTerms] :: Context -> Bool
[insideSubObject] :: Context -> Bool
sameContext :: Context -> Context -> Bool

-- | A rule tries to apply a transformation to the root object, if
--   possible.
type Rule = Context -> Object -> [Object]
applyOneRuleAtRoot :: Context -> Object -> [(String, Object)]
extendContextWith :: Object -> Context -> Context
isEmptyBinding :: Binding -> Bool
withSubObject :: (Context -> Object -> [(String, Object)]) -> Context -> Object -> [(String, Object)]

-- | Given a unary function that operates only on plain objects, converts
--   it to a function that operates on named objects
propagateName1 :: (a -> b) -> (name, a) -> (name, b)

-- | Given a binary function that operates only on plain objects, converts
--   it to a function that operates on named objects
propagateName2 :: (a -> b -> c) -> (name, a) -> b -> (name, c)
withSubObjectBindings :: (Context -> Object -> [(String, Object)]) -> Context -> [Binding] -> [(String, [Binding])]
withSubObjectBinding :: (Context -> Object -> [(String, Object)]) -> Context -> Binding -> [(String, Binding)]
applyOneRule :: Context -> Object -> [(String, Object)]
isNF :: Context -> Object -> Bool

-- | Apply rules until we get a normal form.
applyRules :: Context -> Object -> [Object]
data ApplicationLimits
ApplicationLimits :: Int -> Int -> ApplicationLimits
[maxDepth] :: ApplicationLimits -> Int
[maxTermSize] :: ApplicationLimits -> Int
defaultApplicationLimits :: Int -> ApplicationLimits
objectSize :: Object -> Int
bindingSize :: Binding -> Int

-- | A variant of <a>applyRules</a> with a maximum application depth.
applyRulesWith :: ApplicationLimits -> Context -> Object -> [Object]
equalProgram :: Program -> Program -> Bool
equalObject :: Object -> Object -> Bool
equalObjectNamed :: (String, Object) -> (String, Object) -> Bool
equalBindings :: [Binding] -> [Binding] -> Bool
equalBinding :: Binding -> Binding -> Bool
data LogEntry log
LogEntry :: String -> log -> Int -> LogEntry log
[logEntryMessage] :: LogEntry log -> String
[logEntryLog] :: LogEntry log -> log
[logEntryLevel] :: LogEntry log -> Int
newtype Chain log result
Chain :: (Context -> [([LogEntry log], result)]) -> Chain log result
[runChain] :: Chain log result -> Context -> [([LogEntry log], result)]
type NormalizeChain = Chain Object
type DataizeChain = Chain (Either Object Bytes)
logStep :: String -> info -> Chain info ()
incLogLevel :: Chain info a -> Chain info a
choose :: [a] -> Chain log a
msplit :: Chain log a -> Chain log (Maybe (a, Chain log a))
transformLogs :: (log1 -> log2) -> Chain log1 a -> Chain log2 a
transformNormLogs :: NormalizeChain a -> DataizeChain a
listen :: Chain log a -> Chain log (a, [LogEntry log])
minimizeObject' :: DataizeChain (Either Object Bytes) -> DataizeChain (Either Object Bytes)
minimizeObject :: DataizeChain (Either Object Bytes) -> DataizeChain (Either Object Bytes)
smallestObject :: [Either Object bytes] -> Object -> Object
getContext :: Chain a Context
withContext :: Context -> Chain log a -> Chain log a
modifyContext :: (Context -> Context) -> Chain log a -> Chain log a
applyRulesChain' :: Context -> Object -> [([LogEntry Object], Object)]

-- | Apply the rules until the object is normalized, preserving the history
--   (chain) of applications.
applyRulesChain :: Object -> NormalizeChain Object
applyRulesChainWith' :: ApplicationLimits -> Context -> Object -> [([LogEntry Object], Object)]

-- | A variant of <a>applyRulesChain</a> with a maximum application depth.
applyRulesChainWith :: ApplicationLimits -> Object -> NormalizeChain Object

-- | Lookup a binding by the attribute name.
lookupBinding :: Attribute -> [Binding] -> Maybe Object
objectBindings :: Object -> [Binding]
padLeft :: Int -> [Char] -> [Char]

-- | Split a list into chunks of given size. All lists in the result are
--   guaranteed to have length less than or equal to the given size.
--   
--   <pre>
--   &gt;&gt;&gt; chunksOf 2 "012345678"
--   ["01","23","45","67","8"]
--   </pre>
--   
--   See <a>paddedLeftChunksOf</a> for a version with padding to guarantee
--   exact chunk size.
chunksOf :: Int -> [a] -> [[a]]

-- | Split a list into chunks of given size, padding on the left if
--   necessary. All lists in the result are guaranteed to have given size.
--   
--   <pre>
--   &gt;&gt;&gt; paddedLeftChunksOf '0' 2 "1234567"
--   ["01","23","45","67"]
--   
--   &gt;&gt;&gt; paddedLeftChunksOf '0' 2 "123456"
--   ["12","34","56"]
--   </pre>
--   
--   <pre>
--   n &gt; 0  ==&gt;  all (\chunk -&gt; length chunk == n) (paddedLeftChunksOf c n s)
--   </pre>
paddedLeftChunksOf :: a -> Int -> [a] -> [[a]]

-- | Normalize the bytestring representation to fit valid <a>Bytes</a>
--   token.
--   
--   <pre>
--   &gt;&gt;&gt; normalizeBytes "238714ABCDEF"
--   "23-87-14-AB-CD-EF"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; normalizeBytes "0238714ABCDEF"
--   "00-23-87-14-AB-CD-EF"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; normalizeBytes "4"
--   "04-"
--   </pre>
normalizeBytes :: String -> String

-- | Concatenate <a>Bytes</a>. FIXME: we should really use
--   <a>ByteString</a> instead of the underlying <a>String</a>
--   representation.
--   
--   <pre>
--   &gt;&gt;&gt; concatBytes "00-" "01-02"
--   Bytes "00-01-02"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatBytes "03-04" "01-02"
--   Bytes "03-04-01-02"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatBytes "03-04" "01-"
--   Bytes "03-04-01"
--   </pre>
concatBytes :: Bytes -> Bytes -> Bytes

-- | Select a slice (section) of <a>Bytes</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sliceBytes "12-34-56" 1 1
--   Bytes "34-"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sliceBytes "12-34-56" 1 0
--   Bytes "00-"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sliceBytes "12-34-56" 0 2
--   Bytes "12-34"
--   </pre>
sliceBytes :: Bytes -> Int -> Int -> Bytes

-- | Convert an <a>Int</a> into <a>Bytes</a> representation.
--   
--   <pre>
--   &gt;&gt;&gt; intToBytes 7
--   Bytes "00-00-00-00-00-00-00-07"
--   
--   &gt;&gt;&gt; intToBytes (3^33)
--   Bytes "00-13-BF-EF-A6-5A-BB-83"
--   
--   &gt;&gt;&gt; intToBytes (-1)
--   Bytes "FF-FF-FF-FF-FF-FF-FF-FF"
--   </pre>
intToBytes :: Int -> Bytes

-- | Parse <a>Bytes</a> as <a>Int</a>.
--   
--   <pre>
--   &gt;&gt;&gt; bytesToInt "00-13-BF-EF-A6-5A-BB-83"
--   5559060566555523
--   
--   &gt;&gt;&gt; bytesToInt "AB-"
--   171
--   </pre>
--   
--   May error on invalid <a>Bytes</a>:
--   
--   <pre>
--   &gt;&gt;&gt; bytesToInt "s"
--   *** Exception: Prelude.head: empty list
--   ...
--   ...
--   ...
--   ...
--   ...
--   ...
--   </pre>
bytesToInt :: Bytes -> Int

-- | Convert <a>Bool</a> to <a>Bytes</a>.
--   
--   <pre>
--   &gt;&gt;&gt; boolToBytes False
--   Bytes "00-"
--   
--   &gt;&gt;&gt; boolToBytes True
--   Bytes "01-"
--   </pre>
boolToBytes :: Bool -> Bytes

-- | Interpret <a>Bytes</a> as <a>Bool</a>.
--   
--   Zero is interpreted as <a>False</a>.
--   
--   <pre>
--   &gt;&gt;&gt; bytesToBool "00-"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bytesToBool "00-00"
--   False
--   </pre>
--   
--   Everything else is interpreted as <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; bytesToBool "01-"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bytesToBool "00-01"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bytesToBool "AB-CD"
--   True
--   </pre>
bytesToBool :: Bytes -> Bool

-- | Encode <a>String</a> as <a>Bytes</a>.
--   
--   <pre>
--   &gt;&gt;&gt; stringToBytes "Hello, world!"
--   Bytes "48-65-6C-6C-6F-2C-20-77-6F-72-6C-64-21"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringToBytes "–ü—Ä–∏–≤–µ—Ç, –º–∏—Ä!"
--   Bytes "D0-9F-D1-80-D0-B8-D0-B2-D0-B5-D1-82-2C-20-D0-BC-D0-B8-D1-80-21"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringToBytes  "hello, Â§ßÂÆ∂!"
--   Bytes "68-65-6C-6C-6F-2C-20-E5-A4-A7-E5-AE-B6-21"
--   </pre>
stringToBytes :: String -> Bytes
bytestringToBytes :: ByteString -> Bytes
bytesToByteString :: Bytes -> ByteString

-- | Decode <a>String</a> from <a>Bytes</a>.
--   
--   <pre>
--   &gt;&gt;&gt; bytesToString "48-65-6C-6C-6F-2C-20-77-6F-72-6C-64-21"
--   "Hello, world!"
--   </pre>
bytesToString :: Bytes -> String

-- | Encode <a>Double</a> as <a>Bytes</a> following IEEE754.
--   
--   Note: it is called "float" in EO, but it actually occupies 8 bytes so
--   it corresponds to <a>Double</a>.
--   
--   <pre>
--   &gt;&gt;&gt; floatToBytes 0
--   Bytes "00-00-00-00-00-00-00-00"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; floatToBytes (-0.1)
--   Bytes "BF-B9-99-99-99-99-99-9A"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; floatToBytes (1/0)       -- Infinity
--   Bytes "7F-F0-00-00-00-00-00-00"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; floatToBytes (asin 2) `elem` ["FF-F8-00-00-00-00-00-00", "7F-F8-00-00-00-00-00-00"]  -- sNaN or qNaN
--   True
--   </pre>
floatToBytes :: Double -> Bytes

-- | Decode <a>Double</a> from <a>Bytes</a> following IEEE754.
--   
--   <pre>
--   &gt;&gt;&gt; bytesToFloat "00-00-00-00-00-00-00-00"
--   0.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bytesToFloat "BF-B9-99-99-99-99-99-9A"
--   -0.1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bytesToFloat "7F-F0-00-00-00-00-00-00"
--   Infinity
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bytesToFloat "FF-F8-00-00-00-00-00-00"
--   NaN
--   </pre>
bytesToFloat :: Bytes -> Double
isRhoBinding :: Binding -> Bool
hideRhoInBinding :: Binding -> Binding
hideRho :: Object -> Object
hideRhoInBinding1 :: Binding -> Binding
hideRho1 :: Object -> Object
instance GHC.Base.Functor Language.EO.Phi.Rules.Common.LogEntry
instance GHC.Show.Show log => GHC.Show.Show (Language.EO.Phi.Rules.Common.LogEntry log)
instance GHC.Base.Functor (Language.EO.Phi.Rules.Common.Chain log)
instance GHC.Base.Applicative (Language.EO.Phi.Rules.Common.Chain a)
instance GHC.Base.Monad (Language.EO.Phi.Rules.Common.Chain a)
instance Control.Monad.Fail.MonadFail (Language.EO.Phi.Rules.Common.Chain a)
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.Program
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.Object
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.Binding
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.Attribute
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.RuleAttribute
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.PeeledObject
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.ObjectHead
instance Data.String.IsString Language.EO.Phi.Syntax.Abs.MetaId

module Language.EO.Phi.Normalize
normalizeObject :: Object -> State Context Object

-- | Normalize an input ùúë-program.
normalize :: Program -> Program

-- | Split compound object into its head and applications/dispatch actions.
peelObject :: Object -> PeeledObject
unpeelObject :: PeeledObject -> Object
instance GHC.Generics.Generic Language.EO.Phi.Normalize.Context


-- | Pretty-printer for Language.
module Language.EO.Phi.Syntax.Print

-- | The top-level printing method.
printTree :: Print a => a -> String
type Doc = [ShowS] -> [ShowS]
doc :: ShowS -> Doc
render :: Doc -> String
parenth :: Doc -> Doc
concatS :: [ShowS] -> ShowS
concatD :: [Doc] -> Doc
replicateS :: Int -> ShowS -> ShowS

-- | The printer class does the job.
class Print a
prt :: Print a => Int -> a -> Doc
printString :: String -> Doc
mkEsc :: Char -> Char -> ShowS
prPrec :: Int -> Int -> Doc -> Doc
instance Language.EO.Phi.Syntax.Print.Print a => Language.EO.Phi.Syntax.Print.Print [a]
instance Language.EO.Phi.Syntax.Print.Print GHC.Types.Char
instance Language.EO.Phi.Syntax.Print.Print GHC.Base.String
instance Language.EO.Phi.Syntax.Print.Print GHC.Num.Integer.Integer
instance Language.EO.Phi.Syntax.Print.Print GHC.Types.Double
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.Bytes
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.Function
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.LabelId
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.AlphaIndex
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.LabelMetaId
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.TailMetaId
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.BytesMetaId
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.MetaFunctionName
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.Program
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.MetaId
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.Object
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.Binding
instance Language.EO.Phi.Syntax.Print.Print [Language.EO.Phi.Syntax.Abs.Binding]
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.Attribute
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.RuleAttribute
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.PeeledObject
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.ObjectHead
instance Language.EO.Phi.Syntax.Print.Print Language.EO.Phi.Syntax.Abs.ObjectAction
instance Language.EO.Phi.Syntax.Print.Print [Language.EO.Phi.Syntax.Abs.ObjectAction]

module Language.EO.Phi.Syntax

-- | Like <a>printTree</a>, but without spaces around dots and no
--   indentation for curly braces.
printTree :: Print a => a -> String

-- | Remove spaces around dots.
--   
--   <pre>
--   &gt;&gt;&gt; shrinkDots "a ‚Ü¶ Œæ . a" == "a ‚Ü¶ Œæ.a"
--   True
--   </pre>
shrinkDots :: String -> String

module Language.EO.Phi

-- | Default entry point. Parses a ùúë-program from standard input,
--   normalizes, then pretty-prints the result to standard output.
defaultMain :: IO ()

-- | Normalize an input ùúë-program.
normalize :: Program -> Program

-- | Parse a <a>Program</a> or return a parsing error.
parseProgram :: String -> Either String Program

-- | Parse an <a>Object</a> from a <a>String</a>. May throw an <a>error</a>
--   if input has a syntactical or lexical errors.
unsafeParseObject :: String -> Object

-- | Parse a <a>Program</a> from a <a>String</a>. May throw an <a>error</a>
--   if input has a syntactical or lexical errors.
unsafeParseProgram :: String -> Program

module Language.EO.Phi.Rules.Yaml
data RuleSet
RuleSet :: String -> [Rule] -> RuleSet
[$sel:title:RuleSet] :: RuleSet -> String
[$sel:rules:RuleSet] :: RuleSet -> [Rule]
data RuleContext
RuleContext :: Maybe Object -> Maybe Object -> Maybe Attribute -> RuleContext
[$sel:global_object:RuleContext] :: RuleContext -> Maybe Object
[$sel:current_object:RuleContext] :: RuleContext -> Maybe Object
[$sel:current_attribute:RuleContext] :: RuleContext -> Maybe Attribute
data Rule
Rule :: String -> String -> Maybe RuleContext -> Maybe [MetaId] -> Object -> Object -> Maybe [FreshMetaId] -> [Condition] -> [RuleTest] -> Rule
[$sel:name:Rule] :: Rule -> String
[$sel:description:Rule] :: Rule -> String
[$sel:context:Rule] :: Rule -> Maybe RuleContext
[$sel:forall:Rule] :: Rule -> Maybe [MetaId]
[$sel:pattern:Rule] :: Rule -> Object
[$sel:result:Rule] :: Rule -> Object
[$sel:fresh:Rule] :: Rule -> Maybe [FreshMetaId]
[$sel:when:Rule] :: Rule -> [Condition]
[$sel:tests:Rule] :: Rule -> [RuleTest]
data FreshMetaId
FreshMetaId :: LabelMetaId -> Maybe String -> FreshMetaId
[$sel:name:FreshMetaId] :: FreshMetaId -> LabelMetaId
[$sel:prefix:FreshMetaId] :: FreshMetaId -> Maybe String
data RuleTest
RuleTest :: String -> Object -> [Object] -> Maybe [RuleTestOption] -> RuleTest
[$sel:name:RuleTest] :: RuleTest -> String
[$sel:input:RuleTest] :: RuleTest -> Object
[$sel:output:RuleTest] :: RuleTest -> [Object]
[$sel:options:RuleTest] :: RuleTest -> Maybe [RuleTestOption]
newtype RuleTestOption
TakeOne :: Bool -> RuleTestOption
[$sel:take_one:TakeOne] :: RuleTestOption -> Bool
data AttrsInBindings
AttrsInBindings :: [RuleAttribute] -> [Binding] -> AttrsInBindings
[$sel:attrs:AttrsInBindings] :: AttrsInBindings -> [RuleAttribute]
[$sel:bindings:AttrsInBindings] :: AttrsInBindings -> [Binding]
data Condition
IsNF :: Object -> Condition
[$sel:nf:IsNF] :: Condition -> Object
IsNFInsideFormation :: Object -> Condition
[$sel:nf_inside_formation:IsNF] :: Condition -> Object
PresentAttrs :: AttrsInBindings -> Condition
[$sel:present_attrs:IsNF] :: Condition -> AttrsInBindings
AbsentAttrs :: AttrsInBindings -> Condition
[$sel:absent_attrs:IsNF] :: Condition -> AttrsInBindings
AttrNotEqual :: (Attribute, Attribute) -> Condition
[$sel:not_equal:IsNF] :: Condition -> (Attribute, Attribute)
ApplyInSubformations :: Bool -> Condition
[$sel:apply_in_subformations:IsNF] :: Condition -> Bool
ApplyInAbstractSubformations :: Bool -> Condition
[$sel:apply_in_abstract_subformations:IsNF] :: Condition -> Bool
parseRuleSetFromFile :: FilePath -> IO RuleSet
convertRule :: Rule -> Rule
convertRuleNamed :: Rule -> NamedRule
mkFreshSubst :: Context -> Object -> Maybe [FreshMetaId] -> Subst
mkFreshAttributes :: Set LabelId -> [FreshMetaId] -> [(LabelMetaId, Attribute)]
mkFreshAttribute :: Set LabelId -> FreshMetaId -> ((LabelMetaId, Attribute), Set LabelId)
usedLabelIds :: Context -> Set LabelId
objectLabelIds :: Object -> Set LabelId
bindingLabelIds :: Binding -> Set LabelId
attrLabelIds :: Attribute -> Set LabelId
matchContext :: Context -> Maybe RuleContext -> [Subst]
objectMetaIds :: Object -> Set MetaId
bindingMetaIds :: Binding -> Set MetaId
attrMetaIds :: Attribute -> Set MetaId
objectHasMetavars :: Object -> Bool
bindingHasMetavars :: Binding -> Bool
attrHasMetavars :: Attribute -> Bool

-- | Given a condition, and a substition from object matching tells whether
--   the condition matches the object
checkCond :: Context -> Condition -> Subst -> Bool
hasAttr :: RuleAttribute -> [Binding] -> Bool
data OneHoleContext
OneHoleContext :: !ObjectMetaId -> !Object -> OneHoleContext
[$sel:holeMetaId:OneHoleContext] :: OneHoleContext -> !ObjectMetaId
[$sel:contextObject:OneHoleContext] :: OneHoleContext -> !Object
data Subst
Subst :: [(ObjectMetaId, Object)] -> [(BindingsMetaId, [Binding])] -> [(LabelMetaId, Attribute)] -> [(BytesMetaId, Bytes)] -> [(TailMetaId, OneHoleContext)] -> Subst
[$sel:objectMetas:Subst] :: Subst -> [(ObjectMetaId, Object)]
[$sel:bindingsMetas:Subst] :: Subst -> [(BindingsMetaId, [Binding])]
[$sel:attributeMetas:Subst] :: Subst -> [(LabelMetaId, Attribute)]
[$sel:bytesMetas:Subst] :: Subst -> [(BytesMetaId, Bytes)]
[$sel:contextMetas:Subst] :: Subst -> [(TailMetaId, OneHoleContext)]
emptySubst :: Subst
applySubst :: Subst -> Object -> Object
applySubstAttr :: Subst -> Attribute -> Attribute
applySubstBindings :: Subst -> [Binding] -> [Binding]
applySubstBinding :: Subst -> Binding -> [Binding]
mergeSubst :: Subst -> Subst -> Subst
matchObject :: Object -> Object -> [Subst]
matchOneHoleContext :: TailMetaId -> Object -> Object -> [(Subst, OneHoleContext)]

-- | Evaluate meta functions given top-level context as an object and an
--   object
evaluateMetaFuncs :: Object -> Object -> Object
data MetaState
MetaState :: MetaState
evaluateMetaFuncs' :: Object -> State MetaState Object
evaluateMetaFuncsBinding :: Binding -> State MetaState Binding
matchBindings :: [Binding] -> [Binding] -> [Subst]
select :: [a] -> [(a, [a])]
matchFindBinding :: Binding -> [Binding] -> [([Binding], Subst)]
matchBinding :: Binding -> Binding -> [Subst]
matchAttr :: Attribute -> Attribute -> [Subst]
substThis :: Object -> Object -> Object
substThisBinding :: Object -> Binding -> Binding
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.RuleContext
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.RuleContext
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.RuleContext
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.FreshMetaId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.FreshMetaId
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.FreshMetaId
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.RuleTestOption
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.RuleTestOption
instance GHC.Classes.Eq Language.EO.Phi.Rules.Yaml.RuleTestOption
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.RuleTest
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.RuleTest
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.RuleTest
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.AttrsInBindings
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.AttrsInBindings
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.AttrsInBindings
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.Condition
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.Condition
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.Rule
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.Rule
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.Rule
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.RuleSet
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.RuleSet
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.RuleSet
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.OneHoleContext
instance GHC.Generics.Generic Language.EO.Phi.Rules.Yaml.MetaState
instance GHC.Show.Show Language.EO.Phi.Rules.Yaml.Subst
instance GHC.Base.Semigroup Language.EO.Phi.Rules.Yaml.Subst
instance GHC.Base.Monoid Language.EO.Phi.Rules.Yaml.Subst
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.Condition
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Rules.Yaml.RuleTestOption
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.Object
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.Binding
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.ObjectMetaId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.LabelMetaId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.TailMetaId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.BindingsMetaId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.BytesMetaId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.MetaId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.Attribute
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.RuleAttribute
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.LabelId
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Syntax.Abs.AlphaIndex

module Language.EO.Phi.Rules.Fast
withBinding :: (Context -> Object -> Object) -> Context -> Binding -> Binding
isLambdaBinding :: Binding -> Bool
withSubObjects :: (Context -> Object -> Object) -> Context -> Object -> Object

-- | Normalize an object, following a version of call-by-value strategy:
--   
--   <ol>
--   <li>Apply rules in subobjects/subterms before applying a rule at
--   root.</li>
--   <li>Do not apply rules under formations with at least one void (empty)
--   binding.</li>
--   </ol>
--   
--   <pre>
--   runWithYegorRules applyRulesInsideOut "‚ü¶ x ‚Ü¶ ‚ü¶‚üß, y ‚Ü¶ ‚ü¶ z ‚Ü¶ ‚ü¶ w ‚Ü¶ Œæ.œÅ.œÅ.x ‚üß ‚üß ‚üß.y.z.w"
--   </pre>
--   
--   ‚ü¶ œÅ ‚Ü¶ ‚ü¶ œÅ ‚Ü¶ ‚ü¶ ‚üß ‚üß ‚üß
applyRulesInsideOut :: Context -> Object -> Object
fastYegorInsideOutAsRule :: NamedRule
fastYegorInsideOutBinding :: Context -> Binding -> Binding
fastYegorInsideOut :: Context -> Object -> Object

module Language.EO.Phi.Rules.PhiPaper

-- | Rule 6.
rule6 :: Rule

module Language.EO.Phi.Dependencies
bindingAttr :: Binding -> Maybe Attribute
zipBindings :: [Binding] -> [Binding] -> ([Binding], [(Binding, Binding)])
isPackage :: [Binding] -> Bool
isPackageBinding :: Binding -> Bool
mergeBinding :: Binding -> Binding -> Either String Binding
mergeBindings :: [Binding] -> [Binding] -> Either String [Binding]
deepMerge :: Program -> Program -> Either String Program
deepMergePrograms :: [Program] -> Either String Program

module Language.EO.Phi.Dataize

-- | Perform one step of dataization to the object (if possible).
dataizeStep :: Context -> Object -> (Context, Either Object Bytes)
dataizeStep' :: Context -> Object -> Either Object Bytes

-- | Recursively perform normalization and dataization until we get bytes
--   in the end.
dataizeRecursively :: Context -> Object -> Either Object Bytes
dataizeStepChain' :: Context -> Object -> ([LogEntry (Either Object Bytes)], Either Object Bytes)

-- | Perform one step of dataization to the object (if possible), reporting
--   back individiual steps.
dataizeStepChain :: Object -> DataizeChain (Context, Either Object Bytes)
dataizeRecursivelyChain' :: Context -> Object -> ([LogEntry (Either Object Bytes)], Either Object Bytes)

-- | Recursively perform normalization and dataization until we get bytes
--   in the end, reporting intermediate steps
dataizeRecursivelyChain :: Bool -> Object -> DataizeChain (Either Object Bytes)

-- | Given converters between Bytes and some data type, a binary function
--   on this data type, an object, and the current state of evaluation,
--   returns the new object and a possibly modified state along with
--   intermediate steps.
evaluateDataizationFunChain :: (res -> Bytes) -> (Bytes -> a) -> (Bytes -> Object) -> (a -> a -> res) -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateBinaryDataizationFunChain :: (res -> Bytes) -> (Bytes -> a) -> (Bytes -> Object) -> (Object -> Object) -> (Object -> Object) -> (a -> a -> res) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)

-- | Unary functions operate on the given object without any additional
--   parameters
evaluateUnaryDataizationFunChain :: (res -> Bytes) -> (Bytes -> a) -> (Bytes -> Object) -> (Object -> Object) -> (a -> res) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateIntIntIntFunChain :: (Int -> Int -> Int) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateIntIntBoolFunChain :: (Int -> Int -> Bool) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateBytesBytesBytesFunChain :: (Int -> Int -> Int) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateBytesBytesFunChain :: (Int -> Int) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateFloatFloatFloatFunChain :: (Double -> Double -> Double) -> String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)

-- | Like <a>evaluateDataizationFunChain</a> but specifically for the
--   built-in functions. This function is not safe. It returns undefined
--   for unknown functions
evaluateBuiltinFunChain :: String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
evaluateBuiltinFunChainUnknown :: String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)

-- | Like <tt>evaluateDataizationFun</tt> but specifically for the built-in
--   functions. This function is not safe. It returns undefined for unknown
--   functions
evaluateBuiltinFun :: Context -> String -> Object -> EvaluationState -> (Object, EvaluationState)
evaluateIODataizationFunChain :: IO String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState)
extractRho :: Object -> Object
extractAlpha0 :: Object -> Object
extractLabel :: String -> Object -> Object
wrapBytesInInt :: Bytes -> Object
wrapBytesInFloat :: Bytes -> Object
wrapBytesInString :: Bytes -> Object
wrapBytesInBytes :: Bytes -> Object
wrapTermination :: Object
wrapBytesAsBool :: Bytes -> Object

module Language.EO.Phi.Dataize.Atoms
knownAtomsList :: [(String, String -> Object -> EvaluationState -> DataizeChain (Object, EvaluationState))]

module Language.EO.Phi.Dataize.Context
knownAtomsMap :: Atoms
defaultContext :: [NamedRule] -> Object -> Context
mkEnabledAtoms :: [String] -> [String] -> Atoms

module Language.EO.Phi.Rules.RunYegor
runWithYegorRules :: (Context -> Object -> Object) -> Object -> IO ()
yegorRuleSet :: RuleSet
yegorRules :: [NamedRule]

module Language.EO.Phi.TH
defaultOptions' :: Options
deriveJSON :: Name -> Q [Dec]

module Language.EO.Phi.Pipeline.EOTests.Data
data Pos
Pos :: FilePath -> Int -> Pos
[$sel:file:Pos] :: Pos -> FilePath
[$sel:line:Pos] :: Pos -> Int
data Program
Program :: Pos -> String -> String -> Program
[$sel:source:Program] :: Program -> Pos
[$sel:name:Program] :: Program -> String
[$sel:text:Program] :: Program -> String
data Test
Test :: String -> String -> String -> [Program] -> Test
[$sel:source:Test] :: Test -> String
[$sel:license:Test] :: Test -> String
[$sel:meta:Test] :: Test -> String
[$sel:programs:Test] :: Test -> [Program]
data TestContent
TestContent :: FilePath -> String -> [Program] -> TestContent
[$sel:source:TestContent] :: TestContent -> FilePath
[$sel:meta:TestContent] :: TestContent -> String
[$sel:programs:TestContent] :: TestContent -> [Program]
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.EOTests.Data.TestContent
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.EOTests.Data.TestContent
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.EOTests.Data.TestContent
instance GHC.Show.Show Language.EO.Phi.Pipeline.EOTests.Data.TestContent
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.EOTests.Data.Test
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.EOTests.Data.Test
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.EOTests.Data.Test
instance GHC.Show.Show Language.EO.Phi.Pipeline.EOTests.Data.Test
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.EOTests.Data.Program
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.EOTests.Data.Program
instance GHC.Show.Show Language.EO.Phi.Pipeline.EOTests.Data.Pos
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.EOTests.Data.Program
instance GHC.Show.Show Language.EO.Phi.Pipeline.EOTests.Data.Program
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.EOTests.Data.Pos
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.EOTests.Data.Pos

module Language.EO.Phi.Metrics.Data
data Metrics a
Metrics :: a -> a -> a -> a -> Metrics a
[$sel:dataless:Metrics] :: Metrics a -> a
[$sel:applications:Metrics] :: Metrics a -> a
[$sel:formations:Metrics] :: Metrics a -> a
[$sel:dispatches:Metrics] :: Metrics a -> a
toListMetrics :: Metrics a -> [a]
type MetricsCount = Metrics Int
data BindingMetrics
BindingMetrics :: String -> MetricsCount -> BindingMetrics
[$sel:name:BindingMetrics] :: BindingMetrics -> String
[$sel:metrics:BindingMetrics] :: BindingMetrics -> MetricsCount
type Path = [String]
data BindingsByPathMetrics
BindingsByPathMetrics :: Path -> [BindingMetrics] -> BindingsByPathMetrics
[$sel:path:BindingsByPathMetrics] :: BindingsByPathMetrics -> Path
[$sel:bindingsMetrics:BindingsByPathMetrics] :: BindingsByPathMetrics -> [BindingMetrics]
splitStringOn :: Char -> String -> Path
splitPath :: String -> Path
data ObjectMetrics
ObjectMetrics :: Maybe BindingsByPathMetrics -> MetricsCount -> ObjectMetrics
[$sel:bindingsByPathMetrics:ObjectMetrics] :: ObjectMetrics -> Maybe BindingsByPathMetrics
[$sel:thisObjectMetrics:ObjectMetrics] :: ObjectMetrics -> MetricsCount
data ProgramMetrics
ProgramMetrics :: Maybe BindingsByPathMetrics -> MetricsCount -> ProgramMetrics
[$sel:bindingsByPathMetrics:ProgramMetrics] :: ProgramMetrics -> Maybe BindingsByPathMetrics
[$sel:programMetrics:ProgramMetrics] :: ProgramMetrics -> MetricsCount
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Metrics.Data.ProgramMetrics
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Metrics.Data.ProgramMetrics
instance GHC.Classes.Eq Language.EO.Phi.Metrics.Data.ProgramMetrics
instance GHC.Generics.Generic Language.EO.Phi.Metrics.Data.ProgramMetrics
instance GHC.Show.Show Language.EO.Phi.Metrics.Data.ProgramMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Metrics.Data.ObjectMetrics
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Metrics.Data.ObjectMetrics
instance GHC.Classes.Eq Language.EO.Phi.Metrics.Data.BindingsByPathMetrics
instance GHC.Generics.Generic Language.EO.Phi.Metrics.Data.BindingsByPathMetrics
instance GHC.Show.Show Language.EO.Phi.Metrics.Data.BindingsByPathMetrics
instance GHC.Classes.Eq Language.EO.Phi.Metrics.Data.ObjectMetrics
instance GHC.Generics.Generic Language.EO.Phi.Metrics.Data.ObjectMetrics
instance GHC.Show.Show Language.EO.Phi.Metrics.Data.ObjectMetrics
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Metrics.Data.BindingsByPathMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Metrics.Data.BindingsByPathMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Metrics.Data.BindingMetrics
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Metrics.Data.BindingMetrics
instance GHC.Classes.Eq Language.EO.Phi.Metrics.Data.BindingMetrics
instance GHC.Generics.Generic Language.EO.Phi.Metrics.Data.BindingMetrics
instance GHC.Show.Show Language.EO.Phi.Metrics.Data.BindingMetrics
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Language.EO.Phi.Metrics.Data.Metrics a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Language.EO.Phi.Metrics.Data.Metrics a)
instance GHC.Base.Applicative Language.EO.Phi.Metrics.Data.Metrics
instance GHC.Num.Num a => GHC.Num.Num (Language.EO.Phi.Metrics.Data.Metrics a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Language.EO.Phi.Metrics.Data.Metrics a)
instance GHC.Num.Num a => GHC.Base.Semigroup (Language.EO.Phi.Metrics.Data.Metrics a)
instance GHC.Num.Num a => GHC.Base.Monoid (Language.EO.Phi.Metrics.Data.Metrics a)
instance Data.Traversable.Traversable Language.EO.Phi.Metrics.Data.Metrics
instance Data.Foldable.Foldable Language.EO.Phi.Metrics.Data.Metrics
instance GHC.Base.Functor Language.EO.Phi.Metrics.Data.Metrics
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.EO.Phi.Metrics.Data.Metrics a)
instance GHC.Generics.Generic (Language.EO.Phi.Metrics.Data.Metrics a)
instance GHC.Show.Show a => GHC.Show.Show (Language.EO.Phi.Metrics.Data.Metrics a)

module Language.EO.Phi.Pipeline.Config
data TestSetPhi
TestSetPhi :: FilePath -> FilePath -> Maybe String -> Maybe String -> TestSetPhi
[$sel:initial:TestSetPhi] :: TestSetPhi -> FilePath
[$sel:normalized:TestSetPhi] :: TestSetPhi -> FilePath
[$sel:bindingsPathInitial:TestSetPhi] :: TestSetPhi -> Maybe String
[$sel:bindingsPathNormalized:TestSetPhi] :: TestSetPhi -> Maybe String
data MetricsChangeCategory a
MetricsChange'Good :: a -> MetricsChangeCategory a
[$sel:change:MetricsChange'Good] :: MetricsChangeCategory a -> a
MetricsChange'Bad :: a -> MetricsChangeCategory a
[$sel:change:MetricsChange'Good] :: MetricsChangeCategory a -> a
MetricsChange'NA :: MetricsChangeCategory a
type MetricsChange = Metrics Percent
newtype Percent
Percent :: Double -> Percent
[$sel:percent:Percent] :: Percent -> Double
roundToStr :: Int -> Double -> String
type MetricsChangeCategorized = Metrics (MetricsChangeCategory Percent)
data ReportInput
ReportInput :: Maybe FilePath -> Maybe FilePath -> ReportInput
[$sel:js:ReportInput] :: ReportInput -> Maybe FilePath
[$sel:css:ReportInput] :: ReportInput -> Maybe FilePath
data ReportOutput
ReportOutput :: Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> ReportOutput
[$sel:html:ReportOutput] :: ReportOutput -> Maybe FilePath
[$sel:json:ReportOutput] :: ReportOutput -> Maybe FilePath
[$sel:markdown:ReportOutput] :: ReportOutput -> Maybe FilePath
data ReportConfig
ReportConfig :: Maybe ReportInput -> ReportOutput -> MetricsChange -> Percent -> ReportConfig
[$sel:input:ReportConfig] :: ReportConfig -> Maybe ReportInput
[$sel:output:ReportConfig] :: ReportConfig -> ReportOutput
[$sel:expectedMetricsChange:ReportConfig] :: ReportConfig -> MetricsChange
[$sel:expectedImprovedProgramsPercentage:ReportConfig] :: ReportConfig -> Percent
data TestSetEO
TestSetEO :: FilePath -> FilePath -> FilePath -> Maybe [String] -> Maybe [String] -> TestSetEO
[$sel:original:TestSetEO] :: TestSetEO -> FilePath
[$sel:yaml:TestSetEO] :: TestSetEO -> FilePath
[$sel:filtered:TestSetEO] :: TestSetEO -> FilePath

-- | Program names to include.
--   
--   <a>Nothing</a> is equivalent to all programs.
[$sel:include:TestSetEO] :: TestSetEO -> Maybe [String]

-- | Program names to exclude
--   
--   <a>Nothing</a> is equivalent to no programs.
[$sel:exclude:TestSetEO] :: TestSetEO -> Maybe [String]
data AtomsSet
AtomsSet :: Maybe [String] -> Maybe [String] -> AtomsSet
[$sel:enable:AtomsSet] :: AtomsSet -> Maybe [String]
[$sel:disable:AtomsSet] :: AtomsSet -> Maybe [String]
data TestSet
TestSet :: TestSetEO -> TestSetPhi -> Maybe AtomsSet -> Maybe Bool -> TestSet
[$sel:eo:TestSet] :: TestSet -> TestSetEO
[$sel:phi:TestSet] :: TestSet -> TestSetPhi
[$sel:atoms:TestSet] :: TestSet -> Maybe AtomsSet

-- | Whether to enable this test set.
[$sel:enable:TestSet] :: TestSet -> Maybe Bool
data PipelineConfig
PipelineConfig :: ReportConfig -> [TestSet] -> PipelineConfig
[$sel:report:PipelineConfig] :: PipelineConfig -> ReportConfig
[$sel:testSets:PipelineConfig] :: PipelineConfig -> [TestSet]
data ReportFormat
ReportFormat'Html :: ReportFormat

-- | GitHub Flavored Markdown
ReportFormat'Markdown :: ReportFormat
instance GHC.Classes.Eq Language.EO.Phi.Pipeline.Config.ReportFormat
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.PipelineConfig
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.PipelineConfig
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.PipelineConfig
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.PipelineConfig
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.TestSet
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.TestSet
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.TestSet
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.TestSet
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.AtomsSet
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.AtomsSet
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.AtomsSet
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.AtomsSet
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.TestSetEO
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.TestSetEO
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.TestSetEO
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.TestSetEO
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.ReportConfig
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.ReportConfig
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.ReportConfig
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.ReportConfig
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.ReportOutput
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.ReportOutput
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.ReportOutput
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.ReportOutput
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.ReportInput
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.ReportInput
instance GHC.Float.RealFloat Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Real.RealFrac Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Real.Real Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Classes.Ord Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Classes.Eq Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Float.Floating Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Real.Fractional Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Num.Num Language.EO.Phi.Pipeline.Config.Percent
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.Percent
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.Percent
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.ReportInput
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.ReportInput
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.Percent
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Language.EO.Phi.Pipeline.Config.MetricsChangeCategory a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Language.EO.Phi.Pipeline.Config.MetricsChangeCategory a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.EO.Phi.Pipeline.Config.MetricsChangeCategory a)
instance GHC.Generics.Generic (Language.EO.Phi.Pipeline.Config.MetricsChangeCategory a)
instance GHC.Show.Show a => GHC.Show.Show (Language.EO.Phi.Pipeline.Config.MetricsChangeCategory a)
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Pipeline.Config.TestSetPhi
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Pipeline.Config.TestSetPhi
instance GHC.Generics.Generic Language.EO.Phi.Pipeline.Config.TestSetPhi
instance GHC.Show.Show Language.EO.Phi.Pipeline.Config.TestSetPhi

module Language.EO.Phi.Report.Data
data ReportRow
ReportRow :: Maybe FilePath -> Maybe FilePath -> Maybe Path -> Maybe Path -> Maybe String -> Maybe String -> MetricsChangeCategorized -> Metrics Int -> Metrics Int -> ReportRow
[$sel:fileInitial:ReportRow] :: ReportRow -> Maybe FilePath
[$sel:fileNormalized:ReportRow] :: ReportRow -> Maybe FilePath
[$sel:bindingsPathInitial:ReportRow] :: ReportRow -> Maybe Path
[$sel:bindingsPathNormalized:ReportRow] :: ReportRow -> Maybe Path
[$sel:attributeInitial:ReportRow] :: ReportRow -> Maybe String
[$sel:attributeNormalized:ReportRow] :: ReportRow -> Maybe String
[$sel:metricsChange:ReportRow] :: ReportRow -> MetricsChangeCategorized
[$sel:metricsInitial:ReportRow] :: ReportRow -> Metrics Int
[$sel:metricsNormalized:ReportRow] :: ReportRow -> Metrics Int
data ProgramReport
ProgramReport :: ReportRow -> [ReportRow] -> ProgramReport
[$sel:programRow:ProgramReport] :: ProgramReport -> ReportRow
[$sel:bindingsRows:ProgramReport] :: ProgramReport -> [ReportRow]
data Report
Report :: ReportRow -> [ProgramReport] -> Report
[$sel:totalRow:Report] :: Report -> ReportRow
[$sel:programReports:Report] :: Report -> [ProgramReport]
calculateMetricsChange :: MetricsChange -> MetricsCount -> MetricsCount -> MetricsChangeCategorized
makeProgramReport :: PipelineConfig -> TestSetPhi -> ProgramMetrics -> ProgramMetrics -> ProgramReport
makeReport :: PipelineConfig -> [ProgramReport] -> Report
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Report.Data.Report
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Report.Data.Report
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Report.Data.ProgramReport
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Report.Data.ProgramReport
instance Data.Aeson.Types.ToJSON.ToJSON Language.EO.Phi.Report.Data.ReportRow
instance Data.Aeson.Types.FromJSON.FromJSON Language.EO.Phi.Report.Data.ReportRow

module Language.EO.Phi.Report.Html

-- | JavaScript file to embed into HTML reports
reportJS :: String

-- | CSS file to embed into HTML reports
reportCSS :: String
metricsNames :: Metrics String
toHtmlReportTableHeader :: Html
class (Num a) => ToDataSort a
toDataSort :: ToDataSort a => a -> Integer
mkDataSortAttribute :: AttributeValue -> Attribute
toHtmlChange :: forall a. (ToMarkup a, ToDataSort a) => ReportFormat -> MetricsChangeCategory a -> Html
toHtmlMetricsChange :: ReportFormat -> MetricsChangeCategorized -> [Html]
toHtmlMetrics :: MetricsCount -> [Html]
toHtmlReportRow :: ReportFormat -> Int -> ReportRow -> Html
toHtmlReport :: ReportFormat -> PipelineConfig -> Report -> Html

-- | <pre>
--   &gt;&gt;&gt; renderHtml (mkItem 10 "foo" 4)
--   "&lt;li&gt;&lt;b&gt;foo: &lt;/b&gt;4 (40.00%)&lt;/li&gt;"
--   </pre>
mkItem :: Int -> String -> Int -> Html
mkPercentItem :: String -> Percent -> Html
mkPercentage :: Int -> Int -> Percent

-- | <pre>
--   &gt;&gt;&gt; mkNumber 3 5
--   "3 (60.00%)"
--   </pre>
mkNumber :: Int -> Int -> String
toStringReport :: ReportFormat -> PipelineConfig -> Report -> String
instance Language.EO.Phi.Report.Html.ToDataSort GHC.Types.Double
instance Language.EO.Phi.Report.Html.ToDataSort Language.EO.Phi.Pipeline.Config.Percent
instance Language.EO.Phi.Report.Html.ToDataSort GHC.Num.Integer.Integer
instance Text.Blaze.ToMarkup Language.EO.Phi.Pipeline.Config.Percent

module Language.EO.Phi.Pipeline.EOTests.PrepareTests
prepareTests :: PipelineConfig -> IO ()
parseProgramsRaw :: ([(Int, [String])], (Int, [[Char]]), Int) -> [[Char]] -> [(Int, String)]
parseTest' :: FilePath -> [String] -> Test
parseTest :: FilePath -> IO Test

module Language.EO.Phi.Pipeline.Dataize.PrintConfigs
printDataizeConfigs :: PipelineConfig -> [String] -> Bool -> IO ()

module Language.EO.Phi.Metrics.Collect
type HeightSafe = Maybe Int
count :: (a -> Bool) -> [a] -> Int
getHeight :: [Binding] -> [HeightSafe] -> HeightSafe
countDataless :: HeightSafe -> Int
type InspectM = State MetricsCount HeightSafe
class Inspectable a
inspect :: Inspectable a => a -> InspectM

-- | Get metrics for an object
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ Œæ, Œ±0 ‚Ü¶ Œ¶.org.eolang.bytes( Œî ‚§ç 00- ) ‚üß"
--   Metrics {dataless = 1, applications = 1, formations = 1, dispatches = 3}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ Œæ, Œî ‚§ç 00- ‚üß"
--   Metrics {dataless = 0, applications = 0, formations = 1, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ Œæ, Œ±1 ‚Ü¶ ‚ü¶ Œî ‚§ç 00- ‚üß ‚üß"
--   Metrics {dataless = 0, applications = 0, formations = 2, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ Œæ, Œ±1 ‚Ü¶ ‚ü¶ Œ±2 ‚Ü¶ ‚ü¶ Œî ‚§ç 00- ‚üß ‚üß ‚üß"
--   Metrics {dataless = 1, applications = 0, formations = 3, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œî ‚§ç 00- ‚üß"
--   Metrics {dataless = 0, applications = 0, formations = 1, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚àÖ ‚üß ‚üß"
--   Metrics {dataless = 2, applications = 0, formations = 2, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚àÖ ‚üß ‚üß ‚üß"
--   Metrics {dataless = 3, applications = 0, formations = 3, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚àÖ ‚üß ‚üß ‚üß ‚üß"
--   Metrics {dataless = 4, applications = 0, formations = 4, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ org ‚Ü¶ ‚ü¶ ‚üß ‚üß"
--   Metrics {dataless = 2, applications = 0, formations = 2, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß.e ‚üß"
--   Metrics {dataless = 5, applications = 1, formations = 5, dispatches = 5}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ Œ¶.something(Œ±1 ‚Ü¶ ‚ü¶ Œ±2 ‚Ü¶ ‚ü¶ Œ±3 ‚Ü¶ ‚ü¶ Œî ‚§ç 01- ‚üß ‚üß ‚üß) ‚üß"
--   Metrics {dataless = 2, applications = 1, formations = 4, dispatches = 1}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c, Œî ‚§ç 01- ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶ Œî ‚§ç 01- ‚üß).d ‚üß.e ‚üß"
--   Metrics {dataless = 2, applications = 1, formations = 5, dispatches = 5}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ org ‚Ü¶ ‚ü¶ Œî ‚§ç 01-, c ‚Ü¶ ‚àÖ ‚üß(c ‚Ü¶ ‚ü¶ ‚üß) ‚üß"
--   Metrics {dataless = 2, applications = 1, formations = 3, dispatches = 0}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œî ‚§ç 01- ‚üß.a ‚üß ‚üß ‚üß ‚üß"
--   Metrics {dataless = 4, applications = 0, formations = 5, dispatches = 1}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getThisObjectMetrics "‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ Œ±0 ‚Ü¶ ‚ü¶ ‚üß.a ‚üß, Œ±0 ‚Ü¶ ‚ü¶ Œî ‚§ç 01- ‚üß.b ‚üß"
--   Metrics {dataless = 3, applications = 0, formations = 4, dispatches = 2}
--   </pre>
getThisObjectMetrics :: Object -> MetricsCount

-- | Get an object by a path within a given object.
--   
--   If no object is accessible by the path, return a prefix of the path
--   that led to a non-formation when the remaining path wasn't empty.
--   &gt;&gt;&gt; flip getObjectByPath ["org", "eolang"] "‚ü¶ org ‚Ü¶ ‚ü¶ eolang
--   ‚Ü¶ ‚ü¶ x ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œ¶.org.eolang.bool ( Œ±0 ‚Ü¶ Œ¶.org.eolang.bytes (Œî ‚§ç 01-) )
--   ‚üß, z ‚Ü¶ ‚ü¶ y ‚Ü¶ ‚ü¶ x ‚Ü¶ ‚àÖ, œÜ ‚Ü¶ Œæ.x ‚üß, œÜ ‚Ü¶ Œ¶.org.eolang.bool ( Œ±0 ‚Ü¶
--   Œ¶.org.eolang.bytes (Œî ‚§ç 01-) ) ‚üß, Œª ‚§ç Package ‚üß, Œª ‚§ç Package ‚üß‚üß" Right
--   (Formation [AlphaBinding (Label (LabelId "x")) (Formation
--   [AlphaBinding Phi (Application (ObjectDispatch (ObjectDispatch
--   (ObjectDispatch GlobalObject (Label (LabelId "org"))) (Label (LabelId
--   "eolang"))) (Label (LabelId "bool"))) [AlphaBinding (Alpha (AlphaIndex
--   "945&amp;0")) (Application (ObjectDispatch (ObjectDispatch
--   (ObjectDispatch GlobalObject (Label (LabelId "org"))) (Label (LabelId
--   "eolang"))) (Label (LabelId "bytes"))) [DeltaBinding (Bytes
--   "01-")])])]),AlphaBinding (Label (LabelId "z")) (Formation
--   [AlphaBinding (Label (LabelId "y")) (Formation [EmptyBinding (Label
--   (LabelId "x")),AlphaBinding Phi (ObjectDispatch ThisObject (Label
--   (LabelId "x")))]),AlphaBinding Phi (Application (ObjectDispatch
--   (ObjectDispatch (ObjectDispatch GlobalObject (Label (LabelId "org")))
--   (Label (LabelId "eolang"))) (Label (LabelId "bool"))) [AlphaBinding
--   (Alpha (AlphaIndex "945&amp;0")) (Application (ObjectDispatch
--   (ObjectDispatch (ObjectDispatch GlobalObject (Label (LabelId "org")))
--   (Label (LabelId "eolang"))) (Label (LabelId "bytes"))) [DeltaBinding
--   (Bytes "01-")])])]),LambdaBinding (Function <a>Package</a>)])
--   
--   <pre>
--   &gt;&gt;&gt; flip getObjectByPath ["a"] "‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß.e ‚üß"
--   Right (ObjectDispatch (Formation [AlphaBinding (Label (LabelId "b")) (Formation [EmptyBinding (Label (LabelId "c")),AlphaBinding (Label (LabelId "d")) (Formation [AlphaBinding Phi (ObjectDispatch (ObjectDispatch ThisObject Rho) (Label (LabelId "c")))])]),AlphaBinding (Label (LabelId "e")) (ObjectDispatch (Application (ObjectDispatch ThisObject (Label (LabelId "b"))) [AlphaBinding (Label (LabelId "c")) (Formation [])]) (Label (LabelId "d")))]) (Label (LabelId "e")))
--   </pre>
getObjectByPath :: Object -> Path -> Either Path Object

-- | Get metrics for bindings of a formation that is accessible by a path
--   within a given object.
--   
--   If no formation is accessible by the path, return a prefix of the path
--   that led to a non-formation when the remaining path wasn't empty.
--   &gt;&gt;&gt; flip getBindingsByPathMetrics ["a"] "‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ,
--   d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß.e ‚üß" Left ["a"]
--   
--   <pre>
--   &gt;&gt;&gt; flip getBindingsByPathMetrics ["a"] "‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß ‚üß"
--   Right (BindingsByPathMetrics {path = ["a"], bindingsMetrics = [BindingMetrics {name = "b", metrics = Metrics {dataless = 2, applications = 0, formations = 2, dispatches = 2}},BindingMetrics {name = "e", metrics = Metrics {dataless = 1, applications = 1, formations = 1, dispatches = 2}}]})
--   </pre>
getBindingsByPathMetrics :: Object -> Path -> Either Path BindingsByPathMetrics

-- | Get metrics for an object and for bindings of a formation accessible
--   by a given path.
--   
--   Combine metrics produced by <a>getThisObjectMetrics</a> and
--   <a>getBindingsByPathMetrics</a>.
--   
--   If no formation is accessible by the path, return a prefix of the path
--   that led to a non-formation when the remaining path wasn't empty.
--   &gt;&gt;&gt; flip getObjectMetrics (Just ["a"]) "‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ,
--   d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß.e ‚üß" Left ["a"]
--   
--   <pre>
--   &gt;&gt;&gt; flip getObjectMetrics (Just ["a"]) "‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß ‚üß"
--   Right (ObjectMetrics {bindingsByPathMetrics = Just (BindingsByPathMetrics {path = ["a"], bindingsMetrics = [BindingMetrics {name = "b", metrics = Metrics {dataless = 2, applications = 0, formations = 2, dispatches = 2}},BindingMetrics {name = "e", metrics = Metrics {dataless = 1, applications = 1, formations = 1, dispatches = 2}}]}), thisObjectMetrics = Metrics {dataless = 5, applications = 1, formations = 5, dispatches = 4}})
--   </pre>
getObjectMetrics :: Object -> Maybe Path -> Either Path ObjectMetrics

-- | Get metrics for a program and for bindings of a formation accessible
--   by a given path.
--   
--   Combine metrics produced by <a>getThisObjectMetrics</a> and
--   <a>getBindingsByPathMetrics</a>.
--   
--   If no formation is accessible by the path, return a prefix of the path
--   that led to a non-formation when the remaining path wasn't empty.
--   &gt;&gt;&gt; flip getProgramMetrics (Just ["org", "eolang"]) "{‚ü¶ org ‚Ü¶
--   ‚ü¶ eolang ‚Ü¶ ‚ü¶ x ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œ¶.org.eolang.bool ( Œ±0 ‚Ü¶ Œ¶.org.eolang.bytes (Œî
--   ‚§ç 01-) ) ‚üß, z ‚Ü¶ ‚ü¶ y ‚Ü¶ ‚ü¶ x ‚Ü¶ ‚àÖ, œÜ ‚Ü¶ Œæ.x ‚üß, œÜ ‚Ü¶ Œ¶.org.eolang.bool ( Œ±0 ‚Ü¶
--   Œ¶.org.eolang.bytes (Œî ‚§ç 01-) ) ‚üß, Œª ‚§ç Package ‚üß, Œª ‚§ç Package ‚üß‚üß }"
--   Right (ProgramMetrics {bindingsByPathMetrics = Just
--   (BindingsByPathMetrics {path = ["org","eolang"], bindingsMetrics =
--   [BindingMetrics {name = "x", metrics = Metrics {dataless = 1,
--   applications = 2, formations = 1, dispatches = 6}},BindingMetrics
--   {name = "z", metrics = Metrics {dataless = 2, applications = 2,
--   formations = 2, dispatches = 7}}]}), programMetrics = Metrics
--   {dataless = 6, applications = 4, formations = 6, dispatches = 13}})
--   
--   <pre>
--   &gt;&gt;&gt; flip getProgramMetrics (Just ["a"]) "{‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß.e ‚üß}"
--   Left ["a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip getProgramMetrics (Just ["a"]) "{‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚ü¶ c ‚Ü¶ ‚àÖ, d ‚Ü¶ ‚ü¶ œÜ ‚Ü¶ Œæ.œÅ.c ‚üß ‚üß, e ‚Ü¶ Œæ.b(c ‚Ü¶ ‚ü¶‚üß).d ‚üß ‚üß}"
--   Right (ProgramMetrics {bindingsByPathMetrics = Just (BindingsByPathMetrics {path = ["a"], bindingsMetrics = [BindingMetrics {name = "b", metrics = Metrics {dataless = 2, applications = 0, formations = 2, dispatches = 2}},BindingMetrics {name = "e", metrics = Metrics {dataless = 1, applications = 1, formations = 1, dispatches = 2}}]}), programMetrics = Metrics {dataless = 5, applications = 1, formations = 5, dispatches = 4}})
--   </pre>
getProgramMetrics :: Program -> Maybe Path -> Either Path ProgramMetrics
instance Language.EO.Phi.Metrics.Collect.Inspectable Language.EO.Phi.Syntax.Abs.Binding
instance Language.EO.Phi.Metrics.Collect.Inspectable Language.EO.Phi.Syntax.Abs.Object

module Language.EO.Phi.ToLaTeX
newtype LaTeX
LaTeX :: String -> LaTeX
[unLaTeX] :: LaTeX -> String
class ToLatex a
toLatex :: ToLatex a => a -> LaTeX
toLatexString :: ToLatex a => a -> String
removeOrgEolang :: String -> String
substituteTau :: String -> String
removeExclamationsMarks :: String -> String
removeAlpha :: String -> String
latexToString :: LaTeX -> String
inMathMode :: LaTeX -> LaTeX
isNonEmptyContext :: Maybe RuleContext -> Bool
ruleToLatexCompact :: Rule -> LaTeX
rulesToLatexCompact :: [Rule] -> LaTeX
instance GHC.Base.Monoid Language.EO.Phi.ToLaTeX.LaTeX
instance GHC.Base.Semigroup Language.EO.Phi.ToLaTeX.LaTeX
instance Data.String.IsString Language.EO.Phi.ToLaTeX.LaTeX
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Syntax.Abs.Program
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Syntax.Abs.Attribute
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Syntax.Abs.Binding
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Syntax.Abs.Object
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Rules.Yaml.RuleContext
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Syntax.Abs.RuleAttribute
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Rules.Yaml.Condition
instance Language.EO.Phi.ToLaTeX.ToLatex Language.EO.Phi.Rules.Yaml.Rule
instance Language.EO.Phi.ToLaTeX.ToLatex [Language.EO.Phi.Rules.Yaml.Rule]
instance GHC.Show.Show Language.EO.Phi.ToLaTeX.LaTeX
